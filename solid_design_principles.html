<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SOLID Design Principles</title>
  <style type="text/css">
    html {
      -webkit-text-size-adjust: 100%;
      padding-bottom: 4em
    }

    body {
      line-height: 1.5em;
      max-width: 40em;
      padding: 0 2%;
      margin: auto
    }
  </style>
</head>

<body>
  <br>
  <a href="index.html">home</a>
  <h1>SOLID Design Principles</h1>
  <small>Feb 16th, 2020</small>
  <p>SOLID principles are the design principles that enable us manage most of the software design problems. The term
    SOLID is an acronym for five design principles intended to make software designs more understandable, flexible and
    maintainable. The SOLID acronym was first introduced by <b>Michael Feathers</b>.</p>
  <li><b>S:</b> Single Responsibility Principle (SRP)</li>
  <li><b>O:</b> Open Closed Principle (OSP)</li>
  <li><b>L:</b> Liskov Substitution Principle (LSP)</li>
  <li><b>I:</b> Interface Segregation Principle (ISP)</li>
  <li><b>D:</b> Dependency Inversion Principle (DIP)</li>
  </br>
  <strong>If we don't follow SOLID Principles, we</strong>
  <li>end up with tight or stong coupling of the code with many other modules/applications</li>
  <li>tight coupling causes time to implement any new requirement, features or any bug fixes and some times it creates
    unknown issues</li>
  <li>end up with a code which is not testable</li>
  <li>end up with duplication of code</li>
  <li>end up creating new bugs by fixing another bug</li>
  <li>end up with many unknown issues in the application development cycle</li>
  </br>
  <strong>Following SOLID principles helps us to</strong>
  <li>Achieve reduction in complexity of code</li>
  <li>Increase readability, extensibility and maintenance</li>
  <li>Reduce error and implement Reuseability</li>
  <li>Achieve better testability</li>
  <li>Reduce tight coupling</li>
  </br>
  <strong>Solution to develop a successful application depends on</strong>
  <li><b>Architecture:</b> choosing an architecture is the first step in designing application based on the
    requirements. Eg. MVC, WEBAPI, MVVM, etc.</li>
  <li><b>Design Principles:</b> Application Development process need to follow the design principles.</li>
  <li><b>Design Patterns:</b> we need to choose correct design patterns to build the software.</li>
  </br>
  <hr>

  <h2>Single Responsibility Principle (SRP)</h2>
  <strong>Defination:</strong>
  <li>A class should have only one reason to change.</li>
  <li>Every modules or class should have responsibility over a single part of the functionality provided by the
    software, and that responsibility should be entirely encapsulated by the class.</li>
  </br>
  <strong>Motivation:</strong>
  <li>Maintainability</li>
  <li>Testability</li>
  <li>Flexibility and Extensibility</li>
  <li>Parallel Development</li>
  <li>Loose Coupling</li>
  </br>
  <strong>Explanation:</strong>
  <li>Each class and module should focus on a single task at a time</li>
  <li>Everything in the class should be related to that single purpose</li>
  <li>There can be many members in the class as long as they related to the single responsibility</li>
  <li>With SRP, classes become smaller and cleaner</li>
  <li>Code is less fragile</li>
  </br>
  <hr>

  <h2>Open Closed Principle (OSP)</h2>
  <li>"Software entities such as classes, modules, functions, etc. should be open for extension, but closed for
    modification"</li>
  <li>Any new functionality should be implemented by adding new classes, attributes and methods, instead of changing the
    current ones or existing ones.</li>
  <li>Bertrand Meyer originated the term OCP. Robert C. Martin considered it as most important principle.</li>
  </br>
  <strong>Implementation Guidelines:</strong>
  <li>The simplest way to apply OCP is to implement the new functionality on new derived classes.</li>
  <li>Allow clients to access the original class with abstract interface.</li>
  </br>
  <strong>If we don't follow OCP</strong>
  <li>end up testing the entire functionality</li>
  <li>QA team need to test the entire flow</li>
  <li>Costly process for the organization</li>
  <li>breaks the single responsibility principle</li>
  For this, we can state that both single responsibility principle and open closed principle are highly dependent on
  each other.
  <li>Maintainance overheads increase on the classes</li>
  If the changes are implemented on the same class, maintainance of the class become difficult since the code of the
  class increases by thousands of unorganized lines.
  </br>
  <hr>

  <h2>Interface Segregation Principle (ISP)</h2>
  <li>"No client should be forced to depend on methods it does not use"</li>
  <li>One fat interface need to be split to many smaller and relevant interfaces so the clients can know about the
    interface that are relevant to them</li>
  <li>The ISP was first used and formulated by Robert C. Martin while consulting for Xerox.</li>
  </br>
  <hr>

  <h2>Liskov Substitution Principle (LSP)</h2>
  <li>"S is a subtype of T, then objects of type T may be replaced with objevts of type S"</li>
  <li>Ability to replace any instance of a parent class with an instance of one of its child classes without negative
    side effects</li>
  <li>Derived types must be completely substitutable for their base types</li>
  <li>Liskov substitution principle (LSP) is particular definition of a subtyping relation, called (strong) behavioural
    subtyping</li>
  <li>If you have a base class and a subclass inheriting from that base class, then the subclass should be substitutable
    for the base class at any point in the program. In other words, wherever you are using the base type, you should be
    able to swap that instance for an instance of the subtype without causing any unwanted behaviour in the program.
  </li>
  <li>Introduced by Barbara Liskov</li>
  <li>Extension of the Open Close Principle</li>
  </br>
  <strong>Implementation Guidelines:</strong>
  <li>No new exceptions can be thrown by the subtype</li>
  <li>clients should not know which specific subtype they are calling</li>
  <li>new derived classes just entend without replacing the functionality of old classes</li>
  </br>
  <hr>

  <h2>Dependency Inversion Principle (DIP)</h2>
  <li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
  <li>Abstraction should not depend on details. Details should depend on abstractions.</li>
  <li>The interaction between high level and low level modules should be thought of as an abstract interaction between
    them.</li>
  <li>Introduced by Robert C. Martin</li>
  Example Usage: Adapter Design Patterns

  </br></br>
  <hr>
  </br>
  <strong>References</strong>
  <li><a href="https://www.youtube.com/watch?v=HLFbeC78YlU&list=PL6n9fhu94yhXjG1w2blMXUzyDrZ_eyOme">
      https://www.youtube.com/watch?v=HLFbeC78YlU&list=PL6n9fhu94yhXjG1w2blMXUzyDrZ_eyOme</a></li>
  <li><a href="https://www.youtube.com/watch?v=L2m-S0Pj_Xk&list=PLdR9bD5hyZiiCr5pDs8tYmzHosz3tqIuD">
      https://www.youtube.com/watch?v=L2m-S0Pj_Xk&list=PLdR9bD5hyZiiCr5pDs8tYmzHosz3tqIuD</a></li>
  <li><a href="https://www.youtube.com/channel/UCbF-4yQQAWw-UnuCd2Azfzg">
      https://www.youtube.com/channel/UCbF-4yQQAWw-UnuCd2Azfzg</a></li>
  <li><a href="https://raygun.com/blog/solid-design-principles/">
      https://raygun.com/blog/solid-design-principles/</a></li>


</body>

</html>